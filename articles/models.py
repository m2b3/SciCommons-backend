import random
import time
import uuid

from django.contrib.contenttypes.fields import GenericForeignKey, GenericRelation
from django.contrib.contenttypes.models import ContentType
from django.core.validators import MaxValueValidator, MinValueValidator
from django.db import models
from django.utils.text import slugify
from faker import Faker

from myapp import settings
from myapp.utils import generate_identicon
from users.models import HashtagRelation, User


class Article(models.Model):
    title = models.CharField(max_length=500)
    abstract = models.TextField()
    # Todo: Add Validator
    authors = models.JSONField(default=list)

    def get_upload_path(instance, filename):
        # Get file extension
        ext = filename.split(".")[-1]
        # Generate unique filename using article ID and timestamp
        unique_filename = (
            f"{instance.id}_{uuid.uuid4().hex[:8]}_{int(time.time())}.{ext}"
        )
        return f"article_images/{settings.ENVIRONMENT}/{unique_filename}"

    article_image_url = models.ImageField(
        upload_to=get_upload_path, null=True, blank=True
    )
    article_link = models.URLField(null=True, blank=True, unique=True)
    submission_type = models.CharField(
        max_length=10, choices=[("Public", "Public"), ("Private", "Private")]
    )
    submitter = models.ForeignKey(
        User, on_delete=models.CASCADE, related_name="submitted_articles", db_index=True
    )
    faqs = models.JSONField(default=list)
    slug = models.SlugField(max_length=255, unique=True, blank=True, db_index=True)
    created_at = models.DateTimeField(auto_now_add=True, db_index=True)
    updated_at = models.DateTimeField(auto_now=True)

    hashtags = GenericRelation(HashtagRelation, related_query_name="articles")

    class Meta:
        indexes = [
            models.Index(fields=["submitter", "created_at"]),
            models.Index(fields=["created_at"]),
            models.Index(fields=["submission_type"]),
            models.Index(fields=["submission_type", "created_at"]),
        ]

    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.title)
            original_slug = self.slug
            while Article.objects.filter(slug=self.slug).exists():
                unique_id = uuid.uuid4().hex[:8]  # Generate a short unique ID
                self.slug = f"{original_slug}-{unique_id}"
        super(Article, self).save(*args, **kwargs)

    def __str__(self):
        return self.title


class ArticlePDF(models.Model):
    def get_pdf_upload_path(instance, filename):
        # Get file extension
        ext = filename.split(".")[-1]
        # Generate unique filename using article ID and timestamp
        unique_filename = (
            f"{instance.article.id}_pdf_{uuid.uuid4().hex[:8]}_{int(time.time())}.{ext}"
        )
        return f"article_pdfs/{settings.ENVIRONMENT}/{unique_filename}"

    article = models.ForeignKey(Article, related_name="pdfs", on_delete=models.CASCADE)
    pdf_file_url = models.FileField(
        upload_to=get_pdf_upload_path, null=True, blank=True
    )
    external_url = models.URLField(null=True, blank=True)
    uploaded_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.article.title} - PDF {self.id}"

    def get_url(self):
        """Return either the local file URL or external URL"""
        if self.pdf_file_url:
            return self.pdf_file_url.url
        return self.external_url


class AnonymousIdentity(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    article = models.ForeignKey("Article", on_delete=models.CASCADE)
    community = models.ForeignKey(
        "communities.Community", null=True, blank=True, on_delete=models.CASCADE
    )
    fake_name = models.CharField(max_length=100)
    identicon = models.TextField(null=True, blank=True)

    class Meta:
        unique_together = ("user", "article", "community")

    @staticmethod
    def generate_reddit_style_username():
        fake = Faker()

        def cap_word():
            return fake.word().capitalize()

        def low_word():
            return fake.word().lower()

        patterns = [
            lambda: f"{cap_word()}_{cap_word()}_{random.randint(1000, 99999)}",
            lambda: f"{cap_word()}_{cap_word()}{random.randint(10000, 999999):x}",
            lambda: f"{low_word()}_{low_word()}",
            lambda: f"{cap_word()}-{cap_word()}",
            lambda: f"{cap_word()}{uuid.uuid4().hex[:4]}",
            lambda: f"{fake.first_name()}_{''.join(random.choices('aeiouy', k=3))}",
            lambda: f"{cap_word()}{random.choice(['', '_'])}{random.randint(10, 99)}",
            lambda: f"{low_word()}_{cap_word()}{random.choice(['.', '-', '_'])}{uuid.uuid4().hex[:5]}",
            lambda: f"{cap_word()}.{low_word()}{random.randint(100, 999)}{cap_word()}",
            lambda: f"{cap_word()}_{cap_word()}{random.choice(['', str(random.randint(1000, 9999))])}",
        ]
        fake_name = random.choice(patterns)()
        return fake_name

    @classmethod
    def get_or_create_fake_name(cls, user, article, community=None):
        identity, created = cls.objects.get_or_create(
            user=user,
            article=article,
            community=community,
            defaults={
                "fake_name": (fake_name := cls.generate_reddit_style_username()),
                "identicon": generate_identicon(fake_name),
            },
        )
        return identity.fake_name


class Review(models.Model):
    REVIEWER = "reviewer"
    MODERATOR = "moderator"
    PUBLIC = "public"
    REVIEW_TYPES = [
        (REVIEWER, "Reviewer Review"),
        (MODERATOR, "Moderator Decision"),
        (PUBLIC, "Public Review"),
    ]

    article = models.ForeignKey(
        Article, related_name="reviews", on_delete=models.CASCADE, db_index=True
    )
    user = models.ForeignKey(User, related_name="reviews", on_delete=models.CASCADE)
    community = models.ForeignKey(
        "communities.Community",
        null=True,
        blank=True,
        on_delete=models.CASCADE,
        db_index=True,
    )
    community_article = models.ForeignKey(
        "communities.CommunityArticle", null=True, blank=True, on_delete=models.CASCADE
    )

    review_type = models.CharField(max_length=10, choices=REVIEW_TYPES, default=PUBLIC)
    rating = models.IntegerField(
        validators=[MinValueValidator(1), MaxValueValidator(5)]
    )
    subject = models.CharField(max_length=255)
    content = models.TextField()
    is_approved = models.BooleanField(default=False)
    version = models.PositiveIntegerField(default=1)
    created_at = models.DateTimeField(auto_now_add=True, db_index=True)
    updated_at = models.DateTimeField(auto_now=True)
    deleted_at = models.DateTimeField(null=True, blank=True)
    reaction = GenericRelation("Reaction", related_query_name="reviews")
    is_pseudonymous = models.BooleanField(default=False, editable=True)

    def __str__(self):
        return (
            f"{self.subject} by {self.user.username} ({self.get_review_type_display()})"
        )

    def save(self, *args, **kwargs):
        if self.pk is not None:
            old_review = Review.objects.get(pk=self.pk)
            # if either the subject or content has changed, create a new version
            if old_review.subject != self.subject or old_review.content != self.content:
                ReviewVersion.objects.create(
                    review=self,
                    rating=old_review.rating,
                    subject=old_review.subject,
                    content=old_review.content,
                    version=old_review.version,
                )
                self.version = old_review.version + 1
        super().save(*args, **kwargs)

    def get_anonymous_name(self):
        return AnonymousIdentity.get_or_create_fake_name(
            self.user, self.article, self.community
        )

    def delete(self, *args, **kwargs):
        ReviewVersion.objects.filter(review=self).delete()
        super().delete(*args, **kwargs)

    class Meta:
        unique_together = ("article", "user", "community")
        indexes = [
            models.Index(fields=["article", "created_at"]),
            models.Index(fields=["community", "article"]),
            models.Index(fields=["user", "article"]),
            models.Index(fields=["community_article"]),
        ]


class ReviewVersion(models.Model):
    review = models.ForeignKey(
        Review, on_delete=models.CASCADE, related_name="versions"
    )
    rating = models.IntegerField()
    subject = models.CharField(max_length=255)
    content = models.TextField()
    version = models.PositiveIntegerField()
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"Version {self.version} of {self.review.subject}"


class ReviewComment(models.Model):
    review = models.ForeignKey(
        Review, on_delete=models.CASCADE, related_name="review_comments"
    )
    review_version = models.ForeignKey(
        ReviewVersion,
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name="review_comments",
    )
    parent = models.ForeignKey(
        "self",
        null=True,
        blank=True,
        on_delete=models.CASCADE,
        related_name="review_replies",
    )
    author = models.ForeignKey(
        User, on_delete=models.CASCADE, related_name="review_comments"
    )
    community = models.ForeignKey(
        "communities.Community", null=True, blank=True, on_delete=models.CASCADE
    )
    rating = models.IntegerField(
        validators=[MinValueValidator(1), MaxValueValidator(5)], null=True, blank=True
    )
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    is_deleted = models.BooleanField(default=False)
    reactions = GenericRelation("Reaction", related_query_name="review_comments")
    is_pseudonymous = models.BooleanField(default=False)

    def __str__(self):
        return f"ReviewComment by {self.author.username}"

    def save(self, *args, **kwargs):
        if self.parent and self.parent.parent and self.parent.parent.parent:
            raise ValueError("Exceeded maximum comment nesting level of 3")
        super().save(*args, **kwargs)

    def get_anonymous_name(self):
        return AnonymousIdentity.get_or_create_fake_name(
            self.author, self.review.article, self.review.community
        )

    class Meta:
        ordering = ["created_at"]


class ReviewCommentRating(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    review = models.ForeignKey(Review, on_delete=models.CASCADE)
    community = models.ForeignKey(
        "communities.Community", null=True, blank=True, on_delete=models.CASCADE
    )
    rating = models.IntegerField(
        validators=[MinValueValidator(1), MaxValueValidator(5)]
    )

    class Meta:
        unique_together = ("user", "review", "community")


class Reaction(models.Model):
    LIKE = 1
    DISLIKE = -1

    VOTE_CHOICES = ((LIKE, "Like"), (DISLIKE, "Dislike"))

    user = models.ForeignKey(User, on_delete=models.CASCADE)
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey("content_type", "object_id")
    vote = models.SmallIntegerField(choices=VOTE_CHOICES)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = ("user", "content_type", "object_id")

    def __str__(self):
        return (
            f"{self.user.username} - {self.get_vote_display()} on {self.content_object}"
        )


"""
Discussion Threads for Articles
"""


class Discussion(models.Model):
    article = models.ForeignKey(
        Article, on_delete=models.CASCADE, related_name="discussions"
    )
    community = models.ForeignKey(
        "communities.Community", null=True, blank=True, on_delete=models.CASCADE
    )
    author = models.ForeignKey(
        User, on_delete=models.CASCADE, related_name="discussions"
    )
    topic = models.CharField(max_length=200)
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    deleted_at = models.DateTimeField(null=True, blank=True)
    reactions = GenericRelation("Reaction")
    is_pseudonymous = models.BooleanField(default=False)

    def __str__(self):
        return f"Discussion: {self.title} (Article: {self.article.title})"

    class Meta:
        ordering = ["-created_at"]

    def get_anonymous_name(self):
        return AnonymousIdentity.get_or_create_fake_name(
            self.author, self.article, self.community
        )


class DiscussionComment(models.Model):
    discussion = models.ForeignKey(
        Discussion, on_delete=models.CASCADE, related_name="discussion_comments"
    )
    community = models.ForeignKey(
        "communities.Community", null=True, blank=True, on_delete=models.CASCADE
    )
    author = models.ForeignKey(
        User, on_delete=models.CASCADE, related_name="authored_discussion_comments"
    )
    parent = models.ForeignKey(
        "self", on_delete=models.CASCADE, null=True, blank=True, related_name="replies"
    )
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    reactions = GenericRelation("Reaction")
    is_pseudonymous = models.BooleanField(default=False)

    def __str__(self):
        return (
            f"Comment by {self.author.username} on Discussion: {self.discussion.title}"
        )

    class Meta:
        ordering = ["created_at"]

    def get_anonymous_name(self):
        return AnonymousIdentity.get_or_create_fake_name(
            self.author, self.discussion.article, self.discussion.community
        )


# # Delete review history when a review is deleted
# @receiver(post_delete, sender=Review)
# def delete_review_history(sender, instance, **kwargs):
#     ReviewHistory.objects.filter(review=instance).delete()


# Todo: Automatically delete reviews and replies after a certain period
# when an article is deleted or review is deleted
# @receiver(post_delete, sender=Review)
# def handle_review_delete(sender, instance, **kwargs):
#     instance.deleted_at = timezone.now()
#     instance.save()


# @receiver(post_delete, sender=Reply)
# def handle_reply_delete(sender, instance, **kwargs):
#     instance.deleted_at = timezone.now()
#     instance.save()
